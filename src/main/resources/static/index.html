<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opes Meliores</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f3f4f6; color: #1f2937; }
        header { background: #1e3a5f; color: white; padding: 1rem 2rem; display: flex; flex-wrap: wrap; align-items: center; gap: 1rem; }
        header h1 { font-size: 1.3rem; margin-right: auto; }
        .controls { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }
        .controls label { font-size: 0.85rem; opacity: 0.85; }
        .controls select, .controls input, .controls button {
            padding: 0.4rem 0.6rem; border: 1px solid #475569; border-radius: 4px;
            font-size: 0.85rem; background: #fff; color: #1f2937;
        }
        .controls button { background: #3b82f6; color: white; border: none; cursor: pointer; font-weight: 600; }
        .controls button:hover { background: #2563eb; }
        #status-bar { background: #fef3c7; color: #92400e; padding: 0.5rem 2rem; font-size: 0.85rem; display: none; }
        #status-bar.error { background: #fee2e2; color: #991b1b; }
        main { padding: 1.5rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(480px, 1fr)); gap: 1.5rem; align-items: start; }

        .ticker-card {
            background: white; border-radius: 8px; padding: 1.2rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: relative; cursor: grab; transition: box-shadow 0.2s, transform 0.2s, border-color 0.2s;
            border: 2px solid transparent;
            resize: both; overflow: hidden;
            display: flex; flex-direction: column;
        }
        .ticker-card:active { cursor: grabbing; }
        .ticker-card.dragging { opacity: 0.5; transform: scale(0.97); }
        .ticker-card.drag-over { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.25), 0 4px 12px rgba(0,0,0,0.15); transform: scale(1.01); }

        .card-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.8rem; }
        .card-header h2 { font-size: 1rem; color: #1e3a5f; }
        .subtitle { font-size: 0.78rem; color: #6b7280; margin-top: 2px; }
        .remove-btn {
            background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 1.2rem; line-height: 1; padding: 0 4px;
        }
        .remove-btn:hover { color: #ef4444; }
        .split-btn {
            background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 0.8rem; padding: 2px 6px; margin-left: 4px;
            border-radius: 3px;
        }
        .split-btn:hover { color: #3b82f6; background: #eff6ff; }

        .ticker-badges { display: flex; flex-wrap: wrap; gap: 0.3rem; margin-bottom: 0.6rem; }
        .ticker-badge {
            display: inline-flex; align-items: center; gap: 0.3rem;
            padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; color: white;
        }
        .ticker-badge .badge-remove {
            background: none; border: none; color: rgba(255,255,255,0.7); cursor: pointer;
            font-size: 0.85rem; line-height: 1; padding: 0; margin-left: 2px;
        }
        .ticker-badge .badge-remove:hover { color: white; }

        .current-price { font-size: 1.4rem; font-weight: 700; color: #111827; margin-bottom: 0.6rem; }
        .prices-row { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 0.6rem; }
        .prices-row .price-item { font-size: 0.85rem; }
        .prices-row .price-item .price-label { font-weight: 600; }

        .chart-container { position: relative; min-height: 240px; flex: 1 1 240px; margin-bottom: 1rem; }
        .perf-table { width: 100%; border-collapse: collapse; font-size: 0.82rem; }
        .perf-table th { text-align: left; padding: 0.4rem 0.6rem; background: #f9fafb; border-bottom: 2px solid #e5e7eb; color: #6b7280; font-weight: 600; }
        .perf-table td { padding: 0.3rem 0.6rem; border-bottom: 1px solid #f3f4f6; }
        .perf-table td[rowspan] { border-bottom: 1px solid #e5e7eb; font-weight: 600; }
        .perf-table .positive { color: #16a34a; font-weight: 600; }
        .perf-table .negative { color: #dc2626; font-weight: 600; }
        .perf-table .na { color: #9ca3af; }

        .loading-overlay {
            position: absolute; inset: 0; background: rgba(255,255,255,0.85); display: flex;
            align-items: center; justify-content: center; border-radius: 8px; z-index: 2;
        }
        .spinner { width: 28px; height: 28px; border: 3px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: spin 0.7s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .card-error { color: #991b1b; font-size: 0.85rem; padding: 1rem; text-align: center; }

        .drag-hint { font-size: 0.72rem; color: #9ca3af; text-align: center; margin-top: 0.6rem; font-style: italic; }

        .range-buttons { display: flex; gap: 0.3rem; margin-bottom: 0.5rem; }
        .range-btn {
            padding: 0.2rem 0.55rem; border: 1px solid #d1d5db; border-radius: 999px;
            background: #f9fafb; color: #374151; font-size: 0.72rem; font-weight: 600;
            cursor: pointer; transition: background 0.15s, color 0.15s, border-color 0.15s;
        }
        .range-btn:hover { background: #e0e7ff; border-color: #93c5fd; }
        .range-btn.active { background: #3b82f6; color: white; border-color: #3b82f6; }

        .drop-indicator {
            position: absolute; pointer-events: none; z-index: 10;
            background: #3b82f6; border-radius: 2px; display: none;
        }

        @media (max-width: 540px) { main { grid-template-columns: 1fr; padding: 0.8rem; } header { padding: 0.8rem; } }
    </style>
</head>
<body>
    <header>
        <h1>Opes Meliores</h1>
        <div class="controls">
            <label for="currency-select">Display currency:</label>
            <select id="currency-select">
                <option value="USD" selected>USD</option>
                <option value="EUR">EUR</option>
                <option value="SEK">SEK</option>
                <option value="XDR">XDR (SDR)</option>
            </select>
            <input id="ticker-input" type="text" placeholder="Add ticker (e.g. AAPL)" style="width:170px">
            <button id="add-btn">Add</button>
            <span style="color:rgba(255,255,255,0.3);margin:0 0.2rem">|</span>
            <button id="save-ws-btn">Save workspace</button>
            <input id="ws-code-input" type="text" placeholder="Workspace code" style="width:110px">
            <button id="load-ws-btn">Load</button>
        </div>
    </header>
    <div id="status-bar"></div>
    <main id="tickers-grid"></main>

    <script>
    (() => {
        // ── Configuration ──
        const API_BASE = '/api/chart/';
        const DEFAULT_TICKERS = ['VT', 'VTI', 'VXUS', 'VOO', 'WEBN.DE', 'SPYI.DE', '0P00000LST.ST'];
        const FOREX_PAIRS = {
            'EURUSD': 'EURUSD=X',
            'USDSEK': 'USDSEK=X',
            'GBPUSD': 'GBPUSD=X',
            'USDJPY': 'USDJPY=X',
            'USDCNY': 'USDCNY=X',
        };
        const XDR_BASKET = { USD: 0.38671, EUR: 0.57813, CNY: 1.0993, JPY: 13.452, GBP: 0.080870 };
        const CHART_COLORS = ['#2563eb','#0891b2','#7c3aed','#059669','#d97706','#dc2626','#db2777','#4f46e5','#0d9488','#ca8a04'];

        // ── State ──
        let nextPanelId = 1;
        const state = {
            panels: [],       // { id, symbols[] }
            currency: 'USD',
            tickerData: {},   // symbol -> { timestamps[], adjClose[], currency, name }
            forexData: {},    // pairKey -> { timestamps[], rates[] }
            charts: {},       // panelId -> Chart instance
        };
        let dragSourcePanelId = null;

        // ── DOM refs ──
        const grid = document.getElementById('tickers-grid');
        const currencySelect = document.getElementById('currency-select');
        const tickerInput = document.getElementById('ticker-input');
        const addBtn = document.getElementById('add-btn');
        const statusBar = document.getElementById('status-bar');

        // ── Utility ──
        function showStatus(msg, isError = false) {
            statusBar.textContent = msg;
            statusBar.className = isError ? 'error' : '';
            statusBar.style.display = msg ? 'block' : 'none';
        }

        function closestIndex(timestamps, target) {
            let lo = 0, hi = timestamps.length - 1;
            while (lo < hi) {
                const mid = (lo + hi) >> 1;
                if (timestamps[mid] < target) lo = mid + 1; else hi = mid;
            }
            if (lo > 0 && Math.abs(timestamps[lo - 1] - target) < Math.abs(timestamps[lo] - target)) return lo - 1;
            return lo;
        }

        function monthsAgo(months) {
            const d = new Date();
            d.setMonth(d.getMonth() - months);
            return d.getTime() / 1000;
        }

        function formatPrice(value, currency) {
            if (value == null || isNaN(value)) return 'N/A';
            const symbols = { USD: '$', EUR: '€', SEK: 'kr ', XDR: 'XDR ' };
            const decimals = currency === 'SEK' ? 1 : (currency === 'XDR' ? 4 : 2);
            const prefix = symbols[currency] || currency + ' ';
            if (currency === 'SEK') return value.toFixed(decimals) + ' kr';
            return prefix + value.toFixed(decimals);
        }

        function findPanel(panelId) {
            return state.panels.find(p => p.id === panelId);
        }

        function findPanelBySymbol(symbol) {
            return state.panels.find(p => p.symbols.includes(symbol));
        }

        function allSymbols() {
            return state.panels.flatMap(p => p.symbols);
        }

        // ── Fetching ──
        async function fetchYahooChart(symbol) {
            const url = `${API_BASE}${encodeURIComponent(symbol)}?range=10y&interval=1d`;
            const resp = await fetch(url, { signal: AbortSignal.timeout(30000) });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const json = await resp.json();
            const result = json?.chart?.result?.[0];
            if (!result) throw new Error(`No data for ${symbol}`);
            const ts = result.timestamp;
            const adjClose = result.indicators?.adjclose?.[0]?.adjclose || result.indicators?.quote?.[0]?.close;
            const meta = result.meta || {};
            const filtered = { timestamps: [], adjClose: [] };
            for (let i = 0; i < ts.length; i++) {
                if (adjClose[i] != null && !isNaN(adjClose[i])) {
                    filtered.timestamps.push(ts[i]);
                    filtered.adjClose.push(adjClose[i]);
                }
            }
            return {
                timestamps: filtered.timestamps,
                adjClose: filtered.adjClose,
                currency: meta.currency || 'USD',
                name: meta.shortName || meta.longName || symbol,
                symbol: meta.symbol || symbol,
            };
        }

        // ── Forex ──
        async function fetchAllForex() {
            const promises = Object.entries(FOREX_PAIRS).map(async ([key, symbol]) => {
                try {
                    const data = await fetchYahooChart(symbol);
                    state.forexData[key] = { timestamps: data.timestamps, rates: data.adjClose };
                } catch (e) { console.warn(`Failed to fetch forex ${key}:`, e.message); }
            });
            await Promise.all(promises);
        }

        function getForexRate(pairKey, timestamp) {
            const fx = state.forexData[pairKey];
            if (!fx || fx.timestamps.length === 0) return null;
            return fx.rates[closestIndex(fx.timestamps, timestamp)];
        }

        function toUSD(price, fromCurrency, timestamp) {
            if (fromCurrency === 'USD') return price;
            if (fromCurrency === 'EUR') { const r = getForexRate('EURUSD', timestamp); return r ? price * r : null; }
            if (fromCurrency === 'SEK') { const r = getForexRate('USDSEK', timestamp); return r ? price / r : null; }
            if (fromCurrency === 'GBP') { const r = getForexRate('GBPUSD', timestamp); return r ? price * r : null; }
            if (fromCurrency === 'JPY') { const r = getForexRate('USDJPY', timestamp); return r ? price / r : null; }
            if (fromCurrency === 'CNY') { const r = getForexRate('USDCNY', timestamp); return r ? price / r : null; }
            return null;
        }

        function fromUSD(priceUSD, toCurrency, timestamp) {
            if (toCurrency === 'USD') return priceUSD;
            if (toCurrency === 'EUR') { const r = getForexRate('EURUSD', timestamp); return r ? priceUSD / r : null; }
            if (toCurrency === 'SEK') { const r = getForexRate('USDSEK', timestamp); return r ? priceUSD * r : null; }
            if (toCurrency === 'XDR') {
                let xdrInUSD = 0;
                for (const [cur, weight] of Object.entries(XDR_BASKET)) {
                    const c = toUSD(weight, cur, timestamp);
                    if (c == null) return null;
                    xdrInUSD += c;
                }
                return priceUSD / xdrInUSD;
            }
            return null;
        }

        function convertPrice(price, fromCurrency, toCurrency, timestamp) {
            if (fromCurrency === toCurrency) return price;
            const usd = toUSD(price, fromCurrency, timestamp);
            if (usd == null) return null;
            return fromUSD(usd, toCurrency, timestamp);
        }

        // ── Performance calculation ──
        function calcPerformance(data, months, targetCurrency) {
            const endIdx = data.timestamps.length - 1;
            if (endIdx < 0) return null;
            const startTs = monthsAgo(months);
            const TOLERANCE = 7 * 86400; // 7 days in seconds
            if (startTs < data.timestamps[0] - TOLERANCE) return null;
            const startIdx = closestIndex(data.timestamps, startTs);
            const endPrice = convertPrice(data.adjClose[endIdx], data.currency, targetCurrency, data.timestamps[endIdx]);
            const startPrice = convertPrice(data.adjClose[startIdx], data.currency, targetCurrency, data.timestamps[startIdx]);
            if (endPrice == null || startPrice == null || startPrice === 0) return null;
            return ((endPrice - startPrice) / startPrice) * 100;
        }

        function getDailyReturns(data, months, targetCurrency) {
            const endIdx = data.timestamps.length - 1;
            if (endIdx < 1) return null;
            const startTs = monthsAgo(months);
            const TOLERANCE = 7 * 86400;
            if (startTs < data.timestamps[0] - TOLERANCE) return null;
            const startIdx = closestIndex(data.timestamps, startTs);
            const returns = [];
            for (let i = startIdx + 1; i <= endIdx; i++) {
                const prev = convertPrice(data.adjClose[i - 1], data.currency, targetCurrency, data.timestamps[i - 1]);
                const curr = convertPrice(data.adjClose[i], data.currency, targetCurrency, data.timestamps[i]);
                if (prev != null && curr != null && prev !== 0) {
                    returns.push((curr - prev) / prev);
                }
            }
            return returns.length > 1 ? returns : null;
        }

        function calcVolatility(data, months, targetCurrency) {
            const returns = getDailyReturns(data, months, targetCurrency);
            if (!returns) return null;
            const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + (r - mean) ** 2, 0) / (returns.length - 1);
            return Math.sqrt(variance) * Math.sqrt(252) * 100;
        }

        function calcSortino(data, months, targetCurrency) {
            const returns = getDailyReturns(data, months, targetCurrency);
            if (!returns) return null;
            const meanDaily = returns.reduce((a, b) => a + b, 0) / returns.length;
            const annualizedReturn = meanDaily * 252;
            const downsideSquares = returns.filter(r => r < 0).map(r => r * r);
            if (downsideSquares.length === 0) return annualizedReturn > 0 ? Infinity : null;
            const downsideDev = Math.sqrt(downsideSquares.reduce((a, b) => a + b, 0) / returns.length) * Math.sqrt(252);
            if (downsideDev === 0) return null;
            return annualizedReturn / downsideDev;
        }

        function calcUPI(data, months, targetCurrency) {
            const endIdx = data.timestamps.length - 1;
            if (endIdx < 1) return null;
            const startTs = monthsAgo(months);
            const TOLERANCE = 7 * 86400;
            if (startTs < data.timestamps[0] - TOLERANCE) return null;
            const startIdx = closestIndex(data.timestamps, startTs);
            let peak = -Infinity;
            let sumSqDD = 0;
            let count = 0;
            const prices = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const p = convertPrice(data.adjClose[i], data.currency, targetCurrency, data.timestamps[i]);
                if (p != null) prices.push(p);
            }
            if (prices.length < 2) return null;
            for (const p of prices) {
                if (p > peak) peak = p;
                const dd = (p - peak) / peak * 100;
                sumSqDD += dd * dd;
                count++;
            }
            const ulcerIndex = Math.sqrt(sumSqDD / count);
            if (ulcerIndex === 0) return null;
            const totalReturn = (prices[prices.length - 1] - prices[0]) / prices[0];
            const years = count / 252;
            const annualizedReturn = (Math.pow(1 + totalReturn, 1 / years) - 1) * 100;
            return annualizedReturn / ulcerIndex;
        }

        function calcCorrelation(dataA, dataB, months, targetCurrency) {
            const returnsA = getDailyReturns(dataA, months, targetCurrency);
            const returnsB = getDailyReturns(dataB, months, targetCurrency);
            if (!returnsA || !returnsB) return null;
            // Align to same length from the end (most recent dates)
            const len = Math.min(returnsA.length, returnsB.length);
            if (len < 5) return null;
            const a = returnsA.slice(-len);
            const b = returnsB.slice(-len);
            const meanA = a.reduce((s, v) => s + v, 0) / len;
            const meanB = b.reduce((s, v) => s + v, 0) / len;
            let cov = 0, varA = 0, varB = 0;
            for (let i = 0; i < len; i++) {
                const da = a[i] - meanA, db = b[i] - meanB;
                cov += da * db;
                varA += da * da;
                varB += db * db;
            }
            if (varA === 0 || varB === 0) return null;
            return cov / Math.sqrt(varA * varB);
        }

        // ── Portfolio calculation functions ──
        function shouldRebalance(prevTs, currTs, frequency) {
            if (frequency === 'daily') return true;
            const prev = new Date(prevTs * 1000);
            const curr = new Date(currTs * 1000);
            if (frequency === 'monthly') return curr.getMonth() !== prev.getMonth() || curr.getFullYear() !== prev.getFullYear();
            if (frequency === 'quarterly') return Math.floor(curr.getMonth() / 3) !== Math.floor(prev.getMonth() / 3) || curr.getFullYear() !== prev.getFullYear();
            if (frequency === 'yearly') return curr.getFullYear() !== prev.getFullYear();
            return true;
        }

        function getPortfolioDailyReturns(symbols, weights, cashRate, months, targetCurrency, rebalance = 'daily') {
            const cutoff = monthsAgo(months);
            const TOLERANCE = 7 * 86400;

            // Build converted price series for each symbol
            const seriesMap = {};
            for (const sym of symbols) {
                const data = state.tickerData[sym];
                if (!data || data.timestamps.length === 0) continue;
                if (cutoff < data.timestamps[0] - TOLERANCE) continue;
                const pts = [];
                for (let i = 0; i < data.timestamps.length; i++) {
                    if (data.timestamps[i] < cutoff) continue;
                    const converted = convertPrice(data.adjClose[i], data.currency, targetCurrency, data.timestamps[i]);
                    if (converted != null) pts.push({ ts: data.timestamps[i], price: converted });
                }
                if (pts.length > 1) seriesMap[sym] = pts;
            }

            const syms = Object.keys(seriesMap);
            if (syms.length === 0) return null;

            // Align all series to the shortest one's timestamps
            const refSym = syms.reduce((a, b) => seriesMap[a].length <= seriesMap[b].length ? a : b);
            const refPts = seriesMap[refSym];

            const aligned = {}; // sym -> prices aligned to ref timestamps
            for (const sym of syms) {
                const pts = seriesMap[sym];
                const tsArr = pts.map(p => p.ts);
                aligned[sym] = refPts.map(rp => {
                    const idx = closestIndex(tsArr, rp.ts);
                    return pts[idx].price;
                });
            }

            const timestamps = refPts.map(p => p.ts);
            const targetCashWeight = 100 - syms.reduce((sum, s) => sum + (weights[s] || 0), 0);

            // Track current notional value per component (start with $100 portfolio)
            let currentWeights = {}; // sym -> current portfolio fraction
            for (const sym of syms) currentWeights[sym] = (weights[sym] || 0) / 100;
            let currentCashWeight = targetCashWeight / 100;

            const returns = [];
            for (let i = 1; i < timestamps.length; i++) {
                // Check if we rebalance at this step (back to target weights)
                if (i > 1 && shouldRebalance(timestamps[i - 1], timestamps[i], rebalance)) {
                    for (const sym of syms) currentWeights[sym] = (weights[sym] || 0) / 100;
                    currentCashWeight = targetCashWeight / 100;
                }

                // Compute portfolio return using current (possibly drifted) weights
                const dailyCashReturn = currentCashWeight * (cashRate / 100 / 252);
                let dayReturn = 0;
                for (const sym of syms) {
                    const prev = aligned[sym][i - 1];
                    const curr = aligned[sym][i];
                    if (prev === 0) continue;
                    const r = (curr - prev) / prev;
                    dayReturn += currentWeights[sym] * r;
                }
                dayReturn += dailyCashReturn;
                returns.push(dayReturn);

                // Update weights to reflect drift (each component grows/shrinks by its return)
                const totalBefore = 1; // normalized
                let totalAfter = 0;
                const newValues = {};
                for (const sym of syms) {
                    const prev = aligned[sym][i - 1];
                    const curr = aligned[sym][i];
                    const r = prev === 0 ? 0 : (curr - prev) / prev;
                    newValues[sym] = currentWeights[sym] * (1 + r);
                    totalAfter += newValues[sym];
                }
                const cashAfter = currentCashWeight * (1 + cashRate / 100 / 252);
                totalAfter += cashAfter;

                if (totalAfter > 0) {
                    for (const sym of syms) currentWeights[sym] = newValues[sym] / totalAfter;
                    currentCashWeight = cashAfter / totalAfter;
                }
            }

            return { timestamps: timestamps.slice(1), returns };
        }

        function getPortfolioChartData(symbols, weights, cashRate, targetCurrency, months, rebalance) {
            const result = getPortfolioDailyReturns(symbols, weights, cashRate, months, targetCurrency, rebalance);
            if (!result) return [];
            const points = [{ x: result.timestamps[0] * 1000, y: 100 }];
            let value = 100;
            for (let i = 0; i < result.returns.length; i++) {
                value *= (1 + result.returns[i]);
                points.push({ x: result.timestamps[i] * 1000, y: value });
            }
            return points;
        }

        function calcPortfolioPerformance(symbols, weights, cashRate, months, targetCurrency, rebalance) {
            const result = getPortfolioDailyReturns(symbols, weights, cashRate, months, targetCurrency, rebalance);
            if (!result || result.returns.length === 0) return null;
            let value = 1;
            for (const r of result.returns) value *= (1 + r);
            return (value - 1) * 100;
        }

        function calcPortfolioVolatility(symbols, weights, cashRate, months, targetCurrency, rebalance) {
            const result = getPortfolioDailyReturns(symbols, weights, cashRate, months, targetCurrency, rebalance);
            if (!result || result.returns.length < 2) return null;
            const mean = result.returns.reduce((a, b) => a + b, 0) / result.returns.length;
            const variance = result.returns.reduce((sum, r) => sum + (r - mean) ** 2, 0) / (result.returns.length - 1);
            return Math.sqrt(variance) * Math.sqrt(252) * 100;
        }

        function calcPortfolioSortino(symbols, weights, cashRate, months, targetCurrency, rebalance) {
            const result = getPortfolioDailyReturns(symbols, weights, cashRate, months, targetCurrency, rebalance);
            if (!result || result.returns.length < 2) return null;
            const meanDaily = result.returns.reduce((a, b) => a + b, 0) / result.returns.length;
            const annualizedReturn = meanDaily * 252;
            const downsideSquares = result.returns.filter(r => r < 0).map(r => r * r);
            if (downsideSquares.length === 0) return annualizedReturn > 0 ? Infinity : null;
            const downsideDev = Math.sqrt(downsideSquares.reduce((a, b) => a + b, 0) / result.returns.length) * Math.sqrt(252);
            if (downsideDev === 0) return null;
            return annualizedReturn / downsideDev;
        }

        function calcPortfolioUPI(symbols, weights, cashRate, months, targetCurrency, rebalance) {
            const result = getPortfolioDailyReturns(symbols, weights, cashRate, months, targetCurrency, rebalance);
            if (!result || result.returns.length < 2) return null;
            let value = 100;
            let peak = 100;
            let sumSqDD = 0;
            let count = 0;
            for (const r of result.returns) {
                value *= (1 + r);
                if (value > peak) peak = value;
                const dd = (value - peak) / peak * 100;
                sumSqDD += dd * dd;
                count++;
            }
            const ulcerIndex = Math.sqrt(sumSqDD / (count + 1)); // +1 for initial point
            if (ulcerIndex === 0) return null;
            const totalReturn = value / 100 - 1;
            const years = (count + 1) / 252;
            const annualizedReturn = (Math.pow(1 + totalReturn, 1 / years) - 1) * 100;
            return annualizedReturn / ulcerIndex;
        }

        // ── Normalization for multi-ticker charts ──
        // Returns { symbol: [{x, y}], ... } with normalized values
        function getNormalizedChartData(symbols, targetCurrency, months = 36) {
            const threeYearsAgo = monthsAgo(months);
            const result = {};

            // Step 1: Build converted price series for each ticker within the 3-year window
            const series = {}; // symbol -> [{ts, price}]
            let earliestStart = Infinity;
            let refSymbol = null;

            for (const sym of symbols) {
                const data = state.tickerData[sym];
                if (!data || data.timestamps.length === 0) continue;
                const pts = [];
                for (let i = 0; i < data.timestamps.length; i++) {
                    if (data.timestamps[i] < threeYearsAgo) continue;
                    const converted = convertPrice(data.adjClose[i], data.currency, targetCurrency, data.timestamps[i]);
                    if (converted != null) {
                        pts.push({ ts: data.timestamps[i], price: converted });
                    }
                }
                if (pts.length > 0) {
                    series[sym] = pts;
                    if (pts[0].ts < earliestStart) {
                        earliestStart = pts[0].ts;
                        refSymbol = sym;
                    }
                }
            }

            if (!refSymbol) return result;

            // Step 2: Normalize the reference ticker to start at 100
            const refSeries = series[refSymbol];
            const refBase = refSeries[0].price;
            if (refBase === 0) return result;

            const refNormalized = refSeries.map(p => ({
                ts: p.ts,
                norm: (p.price / refBase) * 100,
            }));

            result[refSymbol] = refNormalized.map(p => ({ x: p.ts * 1000, y: p.norm }));

            // Step 3: Normalize other tickers
            for (const sym of Object.keys(series)) {
                if (sym === refSymbol) continue;
                const s = series[sym];
                const symBase = s[0].price;
                if (symBase === 0) continue;

                // Find the reference ticker's normalized value at this ticker's start date
                const startTs = s[0].ts;
                const refIdx = closestIndex(refNormalized.map(p => p.ts), startTs);
                const refValueAtStart = refNormalized[refIdx].norm;

                result[sym] = s.map(p => ({
                    x: p.ts * 1000,
                    y: (p.price / symBase) * refValueAtStart,
                }));
            }

            return result;
        }

        // ── Panel rendering ──
        function createPanelCard(panel) {
            const card = document.createElement('div');
            card.className = 'ticker-card';
            card.id = `panel-${panel.id}`;
            card.draggable = true;
            card.dataset.panelId = panel.id;

            // Drag-and-drop handlers
            card.addEventListener('dragstart', onDragStart);
            card.addEventListener('dragend', onDragEnd);
            card.addEventListener('dragover', onDragOver);
            card.addEventListener('dragenter', onDragEnter);
            card.addEventListener('dragleave', onDragLeave);
            card.addEventListener('drop', onDrop);

            if (panel.colSpan > 1) card.style.gridColumn = `span ${panel.colSpan}`;

            const ro = new ResizeObserver(entries => {
                for (const entry of entries) {
                    const w = entry.contentRect.width;
                    // Determine single-column width from the grid's resolved columns
                    const cols = getComputedStyle(grid).gridTemplateColumns.split(' ');
                    const colWidth = parseFloat(cols[0]) || 480;
                    const gap = parseFloat(getComputedStyle(grid).columnGap) || 0;
                    // Calculate how many columns this card should span
                    const span = Math.max(1, Math.min(cols.length, Math.ceil((w + gap) / (colWidth + gap))));
                    if (span !== panel.colSpan) {
                        panel.colSpan = span;
                        card.style.gridColumn = span > 1 ? `span ${span}` : '';
                    }
                    // Track resize dimensions for workspace save
                    panel.resizeWidth = card.offsetWidth;
                    panel.resizeHeight = card.offsetHeight;
                }
            });
            ro.observe(card);

            grid.appendChild(card);
            renderPanelContent(panel);
        }

        function renderPanelContent(panel) {
            const card = document.getElementById(`panel-${panel.id}`);
            if (!card) return;
            const isMulti = panel.symbols.length > 1;
            const loadedSymbols = panel.symbols.filter(s => state.tickerData[s]);
            const pendingSymbols = panel.symbols.filter(s => !state.tickerData[s]);

            const isPortfolio = isMulti && panel.mode === 'portfolio';
            const isPortfolioComparison = panel.mode === 'portfolioComparison';

            // Header
            let headerHTML;
            if (isPortfolioComparison) {
                const subBadgesHTML = panel.subPortfolios.map((sp, i) => {
                    const color = CHART_COLORS[i % CHART_COLORS.length];
                    return `<span class="ticker-badge" style="background:${color}" title="${sp.symbols.join(', ')}">
                        ${sp.name || 'Portfolio'}
                        <button class="badge-remove" data-sub-idx="${i}" data-panel="${panel.id}" title="Remove ${sp.name}">&times;</button>
                    </span>`;
                }).join('');

                headerHTML = `
                    <div class="card-header">
                        <div><h2>Portfolio Comparison</h2><div class="subtitle">Normalized performance (base 100)</div></div>
                        <div style="display:flex;align-items:center;gap:4px">
                            <button class="split-btn" data-merge-portfolios="${panel.id}" title="Merge into single portfolio">Merge</button>
                            <button class="remove-btn" data-panel-remove="${panel.id}" title="Remove panel">&times;</button>
                        </div>
                    </div>
                    <div class="ticker-badges">${subBadgesHTML}</div>`;
            } else if (isMulti) {
                const badgesHTML = panel.symbols.map((sym, i) => {
                    const color = CHART_COLORS[i % CHART_COLORS.length];
                    const data = state.tickerData[sym];
                    const label = data ? `${sym}` : `${sym} (loading)`;
                    return `<span class="ticker-badge" style="background:${color}" title="${data ? data.name : sym}">
                        ${label}
                        <button class="badge-remove" data-panel="${panel.id}" data-symbol="${sym}" title="Remove ${sym}">&times;</button>
                    </span>`;
                }).join('');

                const totalAlloc = panel.symbols.reduce((sum, s) => sum + (panel.weights[s] || 0), 0);

                let titleHTML;
                if (isPortfolio) {
                    const nameVal = (panel.name || 'Portfolio').replace(/"/g, '&quot;');
                    titleHTML = `<input type="text" value="${nameVal}" data-portfolio-name
                        style="font-size:1rem;font-weight:700;color:#1e3a5f;border:none;border-bottom:1px dashed #d1d5db;background:transparent;outline:none;padding:2px 0;width:auto;min-width:80px">`;
                } else {
                    titleHTML = `<h2>Comparison</h2>`;
                }
                const subtitleText = isPortfolio
                    ? `Total allocation: ${totalAlloc}%`
                    : 'Normalized performance (base 100)';

                const modeToggleHTML = `<div class="range-buttons" style="margin-bottom:0.4rem">
                    <button class="range-btn${panel.mode === 'comparison' ? ' active' : ''}" data-mode="comparison">Comparison</button>
                    <button class="range-btn${panel.mode === 'portfolio' ? ' active' : ''}" data-mode="portfolio">Portfolio</button>
                </div>`;

                let weightsHTML = '';
                if (isPortfolio) {
                    const cashWeight = 100 - totalAlloc;
                    const cashLabel = cashWeight < 0 ? 'Leverage' : 'Cash';
                    const weightInputs = panel.symbols.map((sym, i) => {
                        const color = CHART_COLORS[i % CHART_COLORS.length];
                        const w = panel.weights[sym] ?? 0;
                        return `<span style="display:inline-flex;align-items:center;gap:0.2rem;margin-right:0.5rem">
                            <span class="ticker-badge" style="background:${color};margin:0;font-size:0.7rem;padding:0.15rem 0.4rem">${sym}</span>
                            <input type="number" step="1" value="${w}" data-weight-sym="${sym}"
                                style="width:55px;padding:0.2rem 0.3rem;border:1px solid #d1d5db;border-radius:4px;font-size:0.8rem;text-align:right">%
                        </span>`;
                    }).join('');
                    const rebalOpts = ['daily','monthly','quarterly','yearly'].map(v =>
                        `<option value="${v}"${panel.rebalance === v ? ' selected' : ''}>${v.charAt(0).toUpperCase() + v.slice(1)}</option>`
                    ).join('');
                    weightsHTML = `<div style="margin-bottom:0.5rem;font-size:0.82rem;display:flex;flex-wrap:wrap;align-items:center;gap:0.3rem">
                        ${weightInputs}
                    </div>
                    <div style="margin-bottom:0.5rem;font-size:0.82rem;display:flex;flex-wrap:wrap;align-items:center;gap:0.8rem">
                        <span>${cashLabel}: <strong>${cashWeight.toFixed(0)}%</strong></span>
                        <span>Rate: <input type="number" step="0.1" value="${panel.cashRate}" data-cash-rate
                            style="width:60px;padding:0.2rem 0.3rem;border:1px solid #d1d5db;border-radius:4px;font-size:0.8rem;text-align:right">%</span>
                        <span>Rebalance: <select data-rebalance style="padding:0.2rem 0.3rem;border:1px solid #d1d5db;border-radius:4px;font-size:0.8rem">${rebalOpts}</select></span>
                    </div>`;
                }

                const copyBtnHTML = isPortfolio ? `<button class="split-btn" data-copy-panel="${panel.id}" title="Copy portfolio">Copy</button>` : '';

                headerHTML = `
                    <div class="card-header">
                        <div>${titleHTML}<div class="subtitle">${subtitleText}</div></div>
                        <div style="display:flex;align-items:center;gap:4px">
                            ${copyBtnHTML}
                            <button class="remove-btn" data-panel-remove="${panel.id}" title="Remove panel">&times;</button>
                        </div>
                    </div>
                    <div class="ticker-badges">${badgesHTML}</div>
                    ${modeToggleHTML}
                    ${weightsHTML}`;
            } else {
                const sym = panel.symbols[0];
                const data = state.tickerData[sym];
                headerHTML = `
                    <div class="card-header">
                        <div>
                            <h2>${sym}</h2>
                            <div class="subtitle">${data ? `${data.name} (native: ${data.currency})` : 'Loading...'}</div>
                        </div>
                        <button class="remove-btn" data-panel-remove="${panel.id}" title="Remove">&times;</button>
                    </div>`;
            }

            // Price display
            let priceHTML = '';
            if (isPortfolioComparison) {
                priceHTML = '';
            } else if (isMulti && !isPortfolio) {
                const items = loadedSymbols.map(sym => {
                    const data = state.tickerData[sym];
                    const lastIdx = data.timestamps.length - 1;
                    const converted = convertPrice(data.adjClose[lastIdx], data.currency, state.currency, data.timestamps[lastIdx]);
                    return `<span class="price-item"><span class="price-label">${sym}:</span> ${converted != null ? formatPrice(converted, state.currency) : 'N/A'}</span>`;
                }).join('');
                priceHTML = `<div class="prices-row">${items}</div>`;
            } else if (isPortfolio) {
                // No individual prices in portfolio mode
                priceHTML = '';
            } else if (loadedSymbols.length === 1) {
                const data = state.tickerData[loadedSymbols[0]];
                const lastIdx = data.timestamps.length - 1;
                const converted = convertPrice(data.adjClose[lastIdx], data.currency, state.currency, data.timestamps[lastIdx]);
                priceHTML = `<div class="current-price">${converted != null ? formatPrice(converted, state.currency) : 'N/A'}</div>`;
            }

            // Performance table
            const periods = [
                { label: '6 Month', months: 6 },
                { label: '1 Year', months: 12 },
                { label: '3 Year', months: 36 },
                { label: '5 Year', months: 60 },
                { label: '10 Year', months: 120 },
            ];

            const metrics = [
                { key: 'perf', label: 'Return', fn: calcPerformance, fmt: v => { const s = v >= 0 ? '+' : ''; return `${s}${v.toFixed(2)}%`; }, cls: v => v >= 0 ? 'positive' : 'negative' },
                { key: 'vol', label: 'Volatility', fn: calcVolatility, fmt: v => `${v.toFixed(2)}%`, cls: () => '' },
                { key: 'sortino', label: 'Sortino', fn: calcSortino, fmt: v => v === Infinity ? '∞' : v.toFixed(2), cls: v => v >= 0 ? 'positive' : 'negative' },
                { key: 'upi', label: 'UPI', fn: calcUPI, fmt: v => v === Infinity ? '∞' : v.toFixed(2), cls: v => v >= 0 ? 'positive' : 'negative' },
            ];

            let tableHTML;
            if (isPortfolioComparison) {
                // Portfolio comparison table: columns are sub-portfolios
                const subs = panel.subPortfolios;
                const thCols = subs.map((sp, i) => {
                    const color = CHART_COLORS[i % CHART_COLORS.length];
                    return `<th style="color:${color}">${sp.name || 'Portfolio'}</th>`;
                }).join('');
                const subMetrics = [
                    { key: 'perf', label: 'Return', fn: (sp, m) => calcPortfolioPerformance(sp.symbols.filter(s => state.tickerData[s]), sp.weights, sp.cashRate, m, state.currency, sp.rebalance), fmt: v => { const s = v >= 0 ? '+' : ''; return `${s}${v.toFixed(2)}%`; }, cls: v => v >= 0 ? 'positive' : 'negative' },
                    { key: 'vol', label: 'Volatility', fn: (sp, m) => calcPortfolioVolatility(sp.symbols.filter(s => state.tickerData[s]), sp.weights, sp.cashRate, m, state.currency, sp.rebalance), fmt: v => `${v.toFixed(2)}%`, cls: () => '' },
                    { key: 'sortino', label: 'Sortino', fn: (sp, m) => calcPortfolioSortino(sp.symbols.filter(s => state.tickerData[s]), sp.weights, sp.cashRate, m, state.currency, sp.rebalance), fmt: v => v === Infinity ? '∞' : v.toFixed(2), cls: v => v >= 0 ? 'positive' : 'negative' },
                    { key: 'upi', label: 'UPI', fn: (sp, m) => calcPortfolioUPI(sp.symbols.filter(s => state.tickerData[s]), sp.weights, sp.cashRate, m, state.currency, sp.rebalance), fmt: v => v === Infinity ? '∞' : v.toFixed(2), cls: v => v >= 0 ? 'positive' : 'negative' },
                ];
                const rows = [];
                for (const p of periods) {
                    for (const m of subMetrics) {
                        const cells = subs.map(sp => {
                            const val = m.fn(sp, p.months);
                            if (val == null) return `<td class="na">N/A</td>`;
                            return `<td class="${m.cls(val)}">${m.fmt(val)}</td>`;
                        }).join('');
                        const label = m === subMetrics[0] ? `<td rowspan="${subMetrics.length}" style="vertical-align:middle">${p.label}</td>` : '';
                        rows.push(`<tr>${label}<td style="color:#6b7280;font-size:0.75rem">${m.label}</td>${cells}</tr>`);
                    }
                }
                tableHTML = `<table class="perf-table">
                    <thead><tr><th>Period</th><th></th>${thCols}</tr></thead>
                    <tbody>${rows.join('')}</tbody>
                </table>`;
            } else if (isPortfolio) {
                // Portfolio mode: single-ticker layout with combined portfolio stats
                const portfolioMetrics = [
                    { key: 'perf', label: 'Return', fn: (m) => calcPortfolioPerformance(loadedSymbols, panel.weights, panel.cashRate, m, state.currency, panel.rebalance), fmt: v => { const s = v >= 0 ? '+' : ''; return `${s}${v.toFixed(2)}%`; }, cls: v => v >= 0 ? 'positive' : 'negative' },
                    { key: 'vol', label: 'Volatility', fn: (m) => calcPortfolioVolatility(loadedSymbols, panel.weights, panel.cashRate, m, state.currency, panel.rebalance), fmt: v => `${v.toFixed(2)}%`, cls: () => '' },
                    { key: 'sortino', label: 'Sortino', fn: (m) => calcPortfolioSortino(loadedSymbols, panel.weights, panel.cashRate, m, state.currency, panel.rebalance), fmt: v => v === Infinity ? '∞' : v.toFixed(2), cls: v => v >= 0 ? 'positive' : 'negative' },
                    { key: 'upi', label: 'UPI', fn: (m) => calcPortfolioUPI(loadedSymbols, panel.weights, panel.cashRate, m, state.currency, panel.rebalance), fmt: v => v === Infinity ? '∞' : v.toFixed(2), cls: v => v >= 0 ? 'positive' : 'negative' },
                ];
                const thCols = portfolioMetrics.map(m => `<th>${m.label}</th>`).join('');
                const rows = periods.map(p => {
                    const cells = portfolioMetrics.map(m => {
                        const val = m.fn(p.months);
                        if (val == null) return `<td class="na">N/A</td>`;
                        return `<td class="${m.cls(val)}">${m.fmt(val)}</td>`;
                    }).join('');
                    return `<tr><td>${p.label}</td>${cells}</tr>`;
                }).join('');
                tableHTML = `<table class="perf-table">
                    <thead><tr><th>Period</th>${thCols}</tr></thead>
                    <tbody>${rows}</tbody>
                </table>`;
            } else if (isMulti) {
                const thCols = loadedSymbols.map((sym, i) => {
                    const color = CHART_COLORS[i % CHART_COLORS.length];
                    return `<th style="color:${color}">${sym}</th>`;
                }).join('');
                const metricsWithCorr = loadedSymbols.length > 1
                    ? [...metrics, { key: 'corr', label: `Corr(${loadedSymbols[0]})`, fn: null, fmt: v => v.toFixed(2), cls: v => '' }]
                    : metrics;
                const refData = state.tickerData[loadedSymbols[0]];
                const rows = [];
                for (const p of periods) {
                    for (const m of metricsWithCorr) {
                        const cells = loadedSymbols.map((sym, i) => {
                            if (m.key === 'corr') {
                                if (i === 0) return `<td style="color:#6b7280">—</td>`;
                                const val = calcCorrelation(refData, state.tickerData[sym], p.months, state.currency);
                                if (val == null) return `<td class="na">N/A</td>`;
                                return `<td>${m.fmt(val)}</td>`;
                            }
                            const val = m.fn(state.tickerData[sym], p.months, state.currency);
                            if (val == null) return `<td class="na">N/A</td>`;
                            return `<td class="${m.cls(val)}">${m.fmt(val)}</td>`;
                        }).join('');
                        const label = m === metricsWithCorr[0] ? `<td rowspan="${metricsWithCorr.length}" style="vertical-align:middle">${p.label}</td>` : '';
                        rows.push(`<tr>${label}<td style="color:#6b7280;font-size:0.75rem">${m.label}</td>${cells}</tr>`);
                    }
                }
                tableHTML = `<table class="perf-table">
                    <thead><tr><th>Period</th><th></th>${thCols}</tr></thead>
                    <tbody>${rows.join('')}</tbody>
                </table>`;
            } else if (loadedSymbols.length === 1) {
                const data = state.tickerData[loadedSymbols[0]];
                const thCols = metrics.map(m => `<th>${m.label}</th>`).join('');
                const rows = periods.map(p => {
                    const cells = metrics.map(m => {
                        const val = m.fn(data, p.months, state.currency);
                        if (val == null) return `<td class="na">N/A</td>`;
                        return `<td class="${m.cls(val)}">${m.fmt(val)}</td>`;
                    }).join('');
                    return `<tr><td>${p.label}</td>${cells}</tr>`;
                }).join('');
                tableHTML = `<table class="perf-table">
                    <thead><tr><th>Period</th>${thCols}</tr></thead>
                    <tbody>${rows}</tbody>
                </table>`;
            } else {
                tableHTML = '';
            }

            const loadingHTML = pendingSymbols.length > 0
                ? `<div class="loading-overlay"><div class="spinner"></div></div>`
                : '';

            const ranges = [{l:'1M',m:1},{l:'3M',m:3},{l:'6M',m:6},{l:'1Y',m:12},{l:'3Y',m:36},{l:'5Y',m:60},{l:'10Y',m:120}];
            const rangeBtnsHTML = ranges.map(r =>
                `<button class="range-btn${r.m === panel.chartRange ? ' active' : ''}" data-range="${r.m}">${r.l}</button>`
            ).join('');

            card.innerHTML = `
                ${headerHTML}
                ${priceHTML}
                <div class="range-buttons">${rangeBtnsHTML}</div>
                <div class="chart-container"><canvas id="chart-panel-${panel.id}"></canvas></div>
                ${tableHTML}
                <div class="drag-hint">Drag onto card to merge, or between cards to reorder</div>
                ${loadingHTML}`;

            // Bind remove buttons
            card.querySelector(`[data-panel-remove="${panel.id}"]`)?.addEventListener('click', () => removePanel(panel.id));
            card.querySelectorAll('.badge-remove').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (btn.dataset.subIdx !== undefined) {
                        removeSubPortfolio(parseInt(btn.dataset.panel), parseInt(btn.dataset.subIdx));
                    } else {
                        removeSymbolFromPanel(parseInt(btn.dataset.panel), btn.dataset.symbol);
                    }
                });
            });

            // Portfolio name input
            const nameInput = card.querySelector('[data-portfolio-name]');
            if (nameInput) {
                nameInput.addEventListener('change', () => {
                    panel.name = nameInput.value;
                });
            }

            // Copy button
            const copyBtn = card.querySelector(`[data-copy-panel="${panel.id}"]`);
            if (copyBtn) {
                copyBtn.addEventListener('click', (e) => { e.stopPropagation(); copyPanel(panel.id); });
            }

            // Merge portfolios button
            const mergeBtn = card.querySelector(`[data-merge-portfolios="${panel.id}"]`);
            if (mergeBtn) {
                mergeBtn.addEventListener('click', (e) => { e.stopPropagation(); mergeSubPortfolios(panel.id); });
            }

            // Range button handlers
            card.querySelectorAll('.range-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (btn.dataset.range) {
                        panel.chartRange = parseInt(btn.dataset.range);
                    }
                    if (btn.dataset.mode) {
                        panel.mode = btn.dataset.mode;
                        if (panel.mode === 'portfolio') {
                            if (!panel.name) panel.name = 'Portfolio';
                            if (Object.keys(panel.weights).length === 0) {
                                const equalWeight = Math.round(100 / panel.symbols.length);
                                panel.symbols.forEach(s => { panel.weights[s] = equalWeight; });
                            }
                        }
                    }
                    renderPanelContent(panel);
                });
            });

            // Weight input handlers (portfolio mode)
            card.querySelectorAll('[data-weight-sym]').forEach(input => {
                input.addEventListener('change', (e) => {
                    const sym = input.dataset.weightSym;
                    panel.weights[sym] = parseFloat(input.value) || 0;
                    renderPanelContent(panel);
                });
            });
            const cashRateInput = card.querySelector('[data-cash-rate]');
            if (cashRateInput) {
                cashRateInput.addEventListener('change', (e) => {
                    panel.cashRate = parseFloat(cashRateInput.value) || 0;
                    renderPanelContent(panel);
                });
            }
            const rebalSelect = card.querySelector('[data-rebalance]');
            if (rebalSelect) {
                rebalSelect.addEventListener('change', (e) => {
                    panel.rebalance = rebalSelect.value;
                    renderPanelContent(panel);
                });
            }

            // Render chart
            renderPanelChart(panel);
        }

        function renderPanelChart(panel) {
            const canvasId = `chart-panel-${panel.id}`;
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            // Destroy existing chart
            if (state.charts[panel.id]) {
                state.charts[panel.id].destroy();
                delete state.charts[panel.id];
            }

            const loadedSymbols = panel.symbols.filter(s => state.tickerData[s]);
            if (loadedSymbols.length === 0) return;

            const isMulti = panel.symbols.length > 1;
            const cur = state.currency;

            if (panel.mode === 'portfolioComparison') {
                // Portfolio comparison: one line per sub-portfolio
                const subs = panel.subPortfolios;
                const datasets = subs.map((sp, i) => {
                    const spSymbols = sp.symbols.filter(s => state.tickerData[s]);
                    const chartData = getPortfolioChartData(spSymbols, sp.weights, sp.cashRate, cur, panel.chartRange, sp.rebalance);
                    let displayData = chartData;
                    if (chartData.length > 400) {
                        const step = Math.ceil(chartData.length / 400);
                        displayData = chartData.filter((_, j) => j % step === 0 || j === chartData.length - 1);
                    }
                    const color = CHART_COLORS[i % CHART_COLORS.length];
                    return {
                        label: sp.name || 'Portfolio',
                        data: displayData,
                        borderColor: color,
                        backgroundColor: color + '18',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        pointHitRadius: 6,
                        fill: false,
                        tension: 0.1,
                    };
                });

                state.charts[panel.id] = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'nearest', axis: 'x', intersect: false },
                        plugins: {
                            legend: { display: true, position: 'top', labels: { boxWidth: 12, font: { size: 11 } } },
                            tooltip: {
                                callbacks: {
                                    title: items => new Date(items[0].parsed.x).toLocaleDateString(),
                                    label: item => `${item.dataset.label}: ${item.parsed.y.toFixed(2)}`,
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month', displayFormats: { month: 'MMM yy' } },
                                ticks: { maxTicksLimit: 12, font: { size: 10 } },
                                grid: { display: false },
                            },
                            y: {
                                title: { display: true, text: 'Portfolio value (base 100)', font: { size: 10 } },
                                ticks: { font: { size: 10 } },
                                grid: { color: '#f3f4f6' },
                            }
                        }
                    }
                });
            } else if (isMulti && panel.mode === 'portfolio') {
                // Portfolio mode: single combined line
                const chartData = getPortfolioChartData(loadedSymbols, panel.weights, panel.cashRate, cur, panel.chartRange, panel.rebalance);
                let displayData = chartData;
                if (chartData.length > 400) {
                    const step = Math.ceil(chartData.length / 400);
                    displayData = chartData.filter((_, i) => i % step === 0 || i === chartData.length - 1);
                }
                const color = CHART_COLORS[0];

                state.charts[panel.id] = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Portfolio',
                            data: displayData,
                            borderColor: color,
                            backgroundColor: color + '18',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            pointHitRadius: 6,
                            fill: true,
                            tension: 0.1,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: items => new Date(items[0].parsed.x).toLocaleDateString(),
                                    label: item => `Portfolio: ${item.parsed.y.toFixed(2)}`,
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month', displayFormats: { month: 'MMM yy' } },
                                ticks: { maxTicksLimit: 12, font: { size: 10 } },
                                grid: { display: false },
                            },
                            y: {
                                title: { display: true, text: 'Portfolio value (base 100)', font: { size: 10 } },
                                ticks: { font: { size: 10 } },
                                grid: { color: '#f3f4f6' },
                            }
                        }
                    }
                });
            } else if (isMulti) {
                // Normalized multi-ticker chart
                const normalized = getNormalizedChartData(loadedSymbols, cur, panel.chartRange);
                const datasets = loadedSymbols.map((sym, i) => {
                    const data = normalized[sym] || [];
                    const color = CHART_COLORS[i % CHART_COLORS.length];
                    let displayData = data;
                    if (data.length > 400) {
                        const step = Math.ceil(data.length / 400);
                        displayData = data.filter((_, j) => j % step === 0 || j === data.length - 1);
                    }
                    return {
                        label: sym,
                        data: displayData,
                        borderColor: color,
                        backgroundColor: color + '18',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        pointHitRadius: 6,
                        fill: false,
                        tension: 0.1,
                    };
                });

                state.charts[panel.id] = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'nearest', axis: 'x', intersect: false },
                        plugins: {
                            legend: { display: true, position: 'top', labels: { boxWidth: 12, font: { size: 11 } } },
                            tooltip: {
                                callbacks: {
                                    title: items => new Date(items[0].parsed.x).toLocaleDateString(),
                                    label: item => `${item.dataset.label}: ${item.parsed.y.toFixed(2)}`,
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month', displayFormats: { month: 'MMM yy' } },
                                ticks: { maxTicksLimit: 12, font: { size: 10 } },
                                grid: { display: false },
                            },
                            y: {
                                title: { display: true, text: 'Normalized (base 100)', font: { size: 10 } },
                                ticks: { font: { size: 10 } },
                                grid: { color: '#f3f4f6' },
                            }
                        }
                    }
                });
            } else {
                // Single ticker chart (absolute prices)
                const sym = loadedSymbols[0];
                const data = state.tickerData[sym];
                const threeYearsAgo = monthsAgo(panel.chartRange);
                const chartData = [];
                for (let i = 0; i < data.timestamps.length; i++) {
                    if (data.timestamps[i] < threeYearsAgo) continue;
                    const converted = convertPrice(data.adjClose[i], data.currency, cur, data.timestamps[i]);
                    if (converted != null) chartData.push({ x: data.timestamps[i] * 1000, y: converted });
                }
                let displayData = chartData;
                if (chartData.length > 400) {
                    const step = Math.ceil(chartData.length / 400);
                    displayData = chartData.filter((_, i) => i % step === 0 || i === chartData.length - 1);
                }
                const colorIdx = state.panels.indexOf(panel) % CHART_COLORS.length;
                const color = CHART_COLORS[colorIdx >= 0 ? colorIdx : 0];

                state.charts[panel.id] = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: {
                        datasets: [{
                            data: displayData,
                            borderColor: color,
                            backgroundColor: color + '18',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            pointHitRadius: 6,
                            fill: true,
                            tension: 0.1,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: items => new Date(items[0].parsed.x).toLocaleDateString(),
                                    label: item => formatPrice(item.parsed.y, cur),
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: 'month', displayFormats: { month: 'MMM yy' } },
                                ticks: { maxTicksLimit: 12, font: { size: 10 } },
                                grid: { display: false },
                            },
                            y: {
                                title: { display: true, text: cur, font: { size: 10 } },
                                ticks: { font: { size: 10 } },
                                grid: { color: '#f3f4f6' },
                            }
                        }
                    }
                });
            }
        }

        function showPanelError(panelId, message) {
            const card = document.getElementById(`panel-${panelId}`);
            if (!card) return;
            card.innerHTML = `<div class="card-header">
                <div class="card-error">${message}</div>
                <button class="remove-btn" title="Remove">&times;</button>
            </div>`;
            card.querySelector('.remove-btn').addEventListener('click', () => removePanel(panelId));
        }

        // ── Drag and drop ──
        let dropIndicator = null;
        let dropInsertIdx = -1;

        function getDropIndicator() {
            if (!dropIndicator) {
                dropIndicator = document.createElement('div');
                dropIndicator.className = 'drop-indicator';
                document.body.appendChild(dropIndicator);
            }
            return dropIndicator;
        }

        function getInsertIndex(mouseX, mouseY) {
            const cards = [...grid.querySelectorAll('.ticker-card')];
            if (cards.length === 0) return 0;

            // For each card, check if the mouse is in the left/top edge zone
            const EDGE = 40; // px from the edge of a card to trigger reorder instead of merge
            for (let i = 0; i < cards.length; i++) {
                const rect = cards[i].getBoundingClientRect();
                // Left edge zone of this card → insert before it
                if (mouseX >= rect.left - EDGE && mouseX < rect.left + EDGE && mouseY >= rect.top && mouseY <= rect.bottom) {
                    return i;
                }
                // Right edge zone of this card → insert after it
                if (mouseX > rect.right - EDGE && mouseX <= rect.right + EDGE && mouseY >= rect.top && mouseY <= rect.bottom) {
                    return i + 1;
                }
            }

            // Check below/after last card
            const lastRect = cards[cards.length - 1].getBoundingClientRect();
            if (mouseY > lastRect.bottom) return cards.length;

            return -1; // not in an edge zone → will be a merge if over a card
        }

        function showDropIndicatorAt(idx) {
            const cards = [...grid.querySelectorAll('.ticker-card')];
            const ind = getDropIndicator();
            if (idx < 0 || cards.length === 0) {
                ind.style.display = 'none';
                return;
            }
            const gridRect = grid.getBoundingClientRect();
            let x, y, w, h;
            if (idx < cards.length) {
                const rect = cards[idx].getBoundingClientRect();
                x = rect.left - 4;
                y = rect.top;
                w = 4;
                h = rect.height;
            } else {
                const rect = cards[cards.length - 1].getBoundingClientRect();
                x = rect.right + 1;
                y = rect.top;
                w = 4;
                h = rect.height;
            }
            ind.style.display = 'block';
            ind.style.left = (x + window.scrollX) + 'px';
            ind.style.top = (y + window.scrollY) + 'px';
            ind.style.width = w + 'px';
            ind.style.height = h + 'px';
        }

        function hideDropIndicator() {
            if (dropIndicator) dropIndicator.style.display = 'none';
            dropInsertIdx = -1;
        }

        function movePanel(panelId, toIdx) {
            const panel = findPanel(panelId);
            if (!panel) return;
            const fromIdx = state.panels.indexOf(panel);
            if (fromIdx < 0) return;
            if (toIdx === fromIdx || toIdx === fromIdx + 1) return;

            state.panels.splice(fromIdx, 1);
            const adjustedIdx = toIdx > fromIdx ? toIdx - 1 : toIdx;
            state.panels.splice(adjustedIdx, 0, panel);

            const card = document.getElementById(`panel-${panelId}`);
            if (!card) return;
            card.remove();
            const cards = grid.querySelectorAll('.ticker-card');
            if (adjustedIdx >= cards.length) {
                grid.appendChild(card);
            } else {
                grid.insertBefore(card, cards[adjustedIdx]);
            }
        }

        function onDragStart(e) {
            const card = e.currentTarget;
            dragSourcePanelId = parseInt(card.dataset.panelId);
            card.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', dragSourcePanelId);
        }

        function onDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            dragSourcePanelId = null;
            document.querySelectorAll('.ticker-card.drag-over').forEach(el => el.classList.remove('drag-over'));
            hideDropIndicator();
        }

        function onDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            // Compute insertion index based on mouse position near card edges
            const idx = getInsertIndex(e.clientX, e.clientY);
            dropInsertIdx = idx;
            if (idx >= 0) {
                showDropIndicatorAt(idx);
                // In edge zone — remove merge highlight from any card
                document.querySelectorAll('.ticker-card.drag-over').forEach(el => el.classList.remove('drag-over'));
            } else {
                hideDropIndicator();
            }
        }

        function onDragEnter(e) {
            e.preventDefault();
            const card = e.currentTarget;
            const targetId = parseInt(card.dataset.panelId);
            if (targetId !== dragSourcePanelId && dropInsertIdx < 0) {
                card.classList.add('drag-over');
            }
        }

        function onDragLeave(e) {
            const card = e.currentTarget;
            if (!card.contains(e.relatedTarget)) {
                card.classList.remove('drag-over');
            }
        }

        function onDrop(e) {
            e.preventDefault();
            const targetCard = e.currentTarget;
            targetCard.classList.remove('drag-over');
            hideDropIndicator();

            const sourcePanelId = parseInt(e.dataTransfer.getData('text/plain'));
            if (isNaN(sourcePanelId)) return;

            // Check if we're in edge-zone mode (reorder) or center (merge)
            const idx = getInsertIndex(e.clientX, e.clientY);
            if (idx >= 0) {
                movePanel(sourcePanelId, idx);
                return;
            }

            const targetPanelId = parseInt(targetCard.dataset.panelId);
            if (sourcePanelId === targetPanelId || isNaN(targetPanelId)) return;

            mergePanels(targetPanelId, sourcePanelId);
        }

        // ── Panel management ──
        function createPanel(symbols) {
            const panel = { id: nextPanelId++, symbols: [...symbols], chartRange: 36, colSpan: 1, mode: 'comparison', weights: {}, cashRate: 0, rebalance: 'monthly', name: '', subPortfolios: [] };
            state.panels.push(panel);
            return panel;
        }

        function mergePanels(targetPanelId, sourcePanelId) {
            const target = findPanel(targetPanelId);
            const source = findPanel(sourcePanelId);
            if (!target || !source) return;

            const isTargetPortfolioType = target.mode === 'portfolio' || target.mode === 'portfolioComparison';
            const isSourcePortfolioType = source.mode === 'portfolio' || source.mode === 'portfolioComparison';

            if (isTargetPortfolioType && isSourcePortfolioType) {
                // Portfolio-to-portfolio merge → portfolioComparison
                const extractSubs = (panel) => {
                    if (panel.mode === 'portfolioComparison') return panel.subPortfolios.map(sp => ({ ...sp, symbols: [...sp.symbols], weights: { ...sp.weights } }));
                    return [{ name: panel.name || 'Portfolio', symbols: [...panel.symbols], weights: { ...panel.weights }, cashRate: panel.cashRate, rebalance: panel.rebalance }];
                };
                const targetSubs = extractSubs(target);
                const sourceSubs = extractSubs(source);
                target.subPortfolios = [...targetSubs, ...sourceSubs];
                target.mode = 'portfolioComparison';
                target.name = '';
                // Union of all symbols
                const allSyms = new Set();
                for (const sp of target.subPortfolios) sp.symbols.forEach(s => allSyms.add(s));
                target.symbols = [...allSyms];
            } else {
                // Standard merge: move all symbols from source to target (skip duplicates)
                for (const sym of source.symbols) {
                    if (!target.symbols.includes(sym)) {
                        target.symbols.push(sym);
                        if (target.mode === 'portfolio') {
                            target.weights[sym] = 0;
                        }
                    }
                }
            }

            // Remove source panel
            const sourceIdx = state.panels.indexOf(source);
            if (sourceIdx >= 0) state.panels.splice(sourceIdx, 1);
            if (state.charts[source.id]) {
                state.charts[source.id].destroy();
                delete state.charts[source.id];
            }
            const sourceCard = document.getElementById(`panel-${source.id}`);
            if (sourceCard) sourceCard.remove();

            // Re-render target
            renderPanelContent(target);
        }

        function removePanel(panelId) {
            const panel = findPanel(panelId);
            if (!panel) return;
            const idx = state.panels.indexOf(panel);
            if (idx >= 0) state.panels.splice(idx, 1);
            if (state.charts[panelId]) {
                state.charts[panelId].destroy();
                delete state.charts[panelId];
            }
            const card = document.getElementById(`panel-${panelId}`);
            if (card) card.remove();
        }

        function removeSymbolFromPanel(panelId, symbol) {
            const panel = findPanel(panelId);
            if (!panel) return;
            const symIdx = panel.symbols.indexOf(symbol);
            if (symIdx < 0) return;

            if (panel.symbols.length <= 1) {
                // Last symbol — remove the whole panel
                removePanel(panelId);
                return;
            }

            // Remove symbol from this panel, create a new standalone panel for it
            panel.symbols.splice(symIdx, 1);
            delete panel.weights[symbol];

            // If only one symbol left, reset to comparison mode
            if (panel.symbols.length <= 1) {
                panel.mode = 'comparison';
            }

            // Re-render the merged panel
            renderPanelContent(panel);

            // Create new standalone panel
            const newPanel = createPanel([symbol]);
            createPanelCard(newPanel);
            // Data is already loaded, just re-render
            if (state.tickerData[symbol]) {
                renderPanelContent(newPanel);
            }
        }

        function getNextCopyName(baseName) {
            const root = baseName.replace(/\s+#\d+$/, '');
            let maxN = 0;
            for (const p of state.panels) {
                const pName = p.name || '';
                const pRoot = pName.replace(/\s+#\d+$/, '');
                if (pRoot === root) {
                    const match = pName.match(/\s+#(\d+)$/);
                    if (match) maxN = Math.max(maxN, parseInt(match[1]));
                }
            }
            return `${root} #${maxN + 1}`;
        }

        function copyPanel(panelId) {
            const original = findPanel(panelId);
            if (!original) return;
            const newPanel = createPanel([...original.symbols]);
            newPanel.weights = { ...original.weights };
            newPanel.cashRate = original.cashRate;
            newPanel.rebalance = original.rebalance;
            newPanel.mode = original.mode;
            newPanel.chartRange = original.chartRange;
            newPanel.subPortfolios = original.subPortfolios.map(sp => ({ ...sp, symbols: [...sp.symbols], weights: { ...sp.weights } }));
            newPanel.name = getNextCopyName(original.name || 'Portfolio');
            createPanelCard(newPanel);
        }

        function removeSubPortfolio(panelId, idx) {
            const panel = findPanel(panelId);
            if (!panel || panel.mode !== 'portfolioComparison') return;
            const removed = panel.subPortfolios.splice(idx, 1)[0];
            if (!removed) return;

            // Create standalone panel for the removed sub-portfolio
            const newPanel = createPanel([...removed.symbols]);
            newPanel.mode = 'portfolio';
            newPanel.name = removed.name || 'Portfolio';
            newPanel.weights = { ...removed.weights };
            newPanel.cashRate = removed.cashRate;
            newPanel.rebalance = removed.rebalance;
            createPanelCard(newPanel);

            if (panel.subPortfolios.length <= 1) {
                // Convert back to regular portfolio
                const last = panel.subPortfolios[0];
                if (last) {
                    panel.mode = 'portfolio';
                    panel.name = last.name || 'Portfolio';
                    panel.symbols = [...last.symbols];
                    panel.weights = { ...last.weights };
                    panel.cashRate = last.cashRate;
                    panel.rebalance = last.rebalance;
                    panel.subPortfolios = [];
                } else {
                    removePanel(panelId);
                    return;
                }
            } else {
                // Update symbols to union of remaining sub-portfolios
                const allSyms = new Set();
                for (const sp of panel.subPortfolios) sp.symbols.forEach(s => allSyms.add(s));
                panel.symbols = [...allSyms];
            }
            renderPanelContent(panel);
        }

        function mergeSubPortfolios(panelId) {
            const panel = findPanel(panelId);
            if (!panel || panel.mode !== 'portfolioComparison') return;
            const subs = panel.subPortfolios;
            const N = subs.length;
            if (N === 0) return;

            const mergedWeights = {};
            let totalCashRate = 0;
            for (const sp of subs) {
                for (const sym of sp.symbols) {
                    mergedWeights[sym] = (mergedWeights[sym] || 0) + (sp.weights[sym] || 0) * (1 / N);
                }
                totalCashRate += sp.cashRate;
            }
            // Round weights
            for (const sym of Object.keys(mergedWeights)) {
                mergedWeights[sym] = Math.round(mergedWeights[sym] * 100) / 100;
            }

            panel.mode = 'portfolio';
            panel.name = 'Merged Portfolio';
            panel.symbols = Object.keys(mergedWeights);
            panel.weights = mergedWeights;
            panel.cashRate = totalCashRate / N;
            panel.rebalance = subs[0].rebalance;
            panel.subPortfolios = [];
            renderPanelContent(panel);
        }

        // ── Ticker lifecycle ──
        async function loadTicker(symbol) {
            const panel = createPanel([symbol]);
            createPanelCard(panel);
            try {
                const data = await fetchYahooChart(symbol);
                state.tickerData[symbol] = data;
                // Panel may have been merged while loading — find the current panel
                const currentPanel = findPanelBySymbol(symbol);
                if (currentPanel) renderPanelContent(currentPanel);
            } catch (e) {
                console.error(`Error loading ${symbol}:`, e);
                const currentPanel = findPanelBySymbol(symbol);
                if (currentPanel) showPanelError(currentPanel.id, `Failed to load ${symbol}: ${e.message}`);
            }
        }

        function addTicker(symbol) {
            symbol = symbol.trim().toUpperCase();
            if (!symbol) return;
            if (allSymbols().includes(symbol)) {
                showStatus(`${symbol} is already displayed`, true);
                setTimeout(() => showStatus(''), 3000);
                return;
            }
            loadTicker(symbol);
            tickerInput.value = '';
        }

        // ── Currency switch ──
        function onCurrencyChange() {
            state.currency = currencySelect.value;
            for (const panel of state.panels) {
                if (panel.symbols.some(s => state.tickerData[s])) {
                    renderPanelContent(panel);
                }
            }
        }

        // ── Workspace save/load ──
        const saveWsBtn = document.getElementById('save-ws-btn');
        const loadWsBtn = document.getElementById('load-ws-btn');
        const wsCodeInput = document.getElementById('ws-code-input');

        async function saveWorkspace() {
            const panelCards = grid.querySelectorAll('.ticker-card');
            const panelsInOrder = [];
            panelCards.forEach(card => {
                const pid = parseInt(card.dataset.panelId);
                const panel = findPanel(pid);
                if (panel) {
                    panelsInOrder.push({
                        symbols: [...panel.symbols],
                        chartRange: panel.chartRange,
                        colSpan: panel.colSpan,
                        resizeWidth: panel.resizeWidth || null,
                        resizeHeight: panel.resizeHeight || null,
                        mode: panel.mode,
                        weights: { ...panel.weights },
                        cashRate: panel.cashRate,
                        rebalance: panel.rebalance,
                        name: panel.name,
                        subPortfolios: panel.subPortfolios.map(sp => ({ name: sp.name, symbols: [...sp.symbols], weights: { ...sp.weights }, cashRate: sp.cashRate, rebalance: sp.rebalance })),
                    });
                }
            });
            const workspace = { currency: state.currency, panels: panelsInOrder };
            try {
                const resp = await fetch('/api/workspace', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(workspace),
                });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const result = await resp.json();
                wsCodeInput.value = result.code;
                showStatus(`Workspace saved! Code: ${result.code}`);
                setTimeout(() => showStatus(''), 5000);
            } catch (e) {
                showStatus('Failed to save workspace: ' + e.message, true);
                setTimeout(() => showStatus(''), 5000);
            }
        }

        async function loadWorkspace() {
            const code = wsCodeInput.value.trim();
            if (!code || !/^[A-Za-z0-9]+$/.test(code)) {
                showStatus('Please enter a valid workspace code', true);
                setTimeout(() => showStatus(''), 3000);
                return;
            }
            try {
                const resp = await fetch(`/api/workspace/${encodeURIComponent(code)}`);
                if (resp.status === 404) { showStatus('Workspace not found', true); setTimeout(() => showStatus(''), 3000); return; }
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const workspace = await resp.json();

                // Clear existing panels
                for (const panel of [...state.panels]) {
                    if (state.charts[panel.id]) { state.charts[panel.id].destroy(); delete state.charts[panel.id]; }
                }
                state.panels = [];
                grid.innerHTML = '';

                // Set currency
                state.currency = workspace.currency || 'USD';
                currencySelect.value = state.currency;

                // Collect all unique symbols needed
                const allSyms = new Set();
                for (const sp of workspace.panels) {
                    for (const sym of sp.symbols) allSyms.add(sym);
                    if (sp.subPortfolios) {
                        for (const sub of sp.subPortfolios) {
                            for (const sym of sub.symbols) allSyms.add(sym);
                        }
                    }
                }

                // Create panels with saved layout
                for (const sp of workspace.panels) {
                    const panel = { id: nextPanelId++, symbols: [...sp.symbols], chartRange: sp.chartRange || 36, colSpan: sp.colSpan || 1, mode: sp.mode || 'comparison', weights: sp.weights ? { ...sp.weights } : {}, cashRate: sp.cashRate || 0, rebalance: sp.rebalance || 'monthly', name: sp.name || '', subPortfolios: (sp.subPortfolios || []).map(sub => ({ name: sub.name || '', symbols: [...sub.symbols], weights: { ...sub.weights }, cashRate: sub.cashRate || 0, rebalance: sub.rebalance || 'monthly' })) };
                    state.panels.push(panel);
                    const card = document.createElement('div');
                    card.className = 'ticker-card';
                    card.id = `panel-${panel.id}`;
                    card.draggable = true;
                    card.dataset.panelId = panel.id;
                    card.addEventListener('dragstart', onDragStart);
                    card.addEventListener('dragend', onDragEnd);
                    card.addEventListener('dragover', onDragOver);
                    card.addEventListener('dragenter', onDragEnter);
                    card.addEventListener('dragleave', onDragLeave);
                    card.addEventListener('drop', onDrop);
                    if (panel.colSpan > 1) card.style.gridColumn = `span ${panel.colSpan}`;
                    if (sp.resizeWidth) card.style.width = sp.resizeWidth + 'px';
                    if (sp.resizeHeight) card.style.height = sp.resizeHeight + 'px';

                    const ro = new ResizeObserver(entries => {
                        for (const entry of entries) {
                            const w = entry.contentRect.width;
                            const cols = getComputedStyle(grid).gridTemplateColumns.split(' ');
                            const colWidth = parseFloat(cols[0]) || 480;
                            const gap = parseFloat(getComputedStyle(grid).columnGap) || 0;
                            const span = Math.max(1, Math.min(cols.length, Math.ceil((w + gap) / (colWidth + gap))));
                            if (span !== panel.colSpan) {
                                panel.colSpan = span;
                                card.style.gridColumn = span > 1 ? `span ${span}` : '';
                            }
                            panel.resizeWidth = card.offsetWidth;
                            panel.resizeHeight = card.offsetHeight;
                        }
                    });
                    ro.observe(card);

                    card.innerHTML = '<div class="loading-overlay"><div class="spinner"></div></div>';
                    grid.appendChild(card);
                }

                // Fetch ticker data for symbols not already loaded
                showStatus('Loading workspace tickers...');
                const fetches = [...allSyms].filter(sym => !state.tickerData[sym]).map(async sym => {
                    try {
                        const data = await fetchYahooChart(sym);
                        state.tickerData[sym] = data;
                    } catch (e) { console.error(`Failed to load ${sym}:`, e); }
                });
                await Promise.all(fetches);

                // Render all panels
                for (const panel of state.panels) {
                    renderPanelContent(panel);
                }
                showStatus('');
            } catch (e) {
                showStatus('Failed to load workspace: ' + e.message, true);
                setTimeout(() => showStatus(''), 5000);
            }
        }

        // ── Event listeners ──
        currencySelect.addEventListener('change', onCurrencyChange);
        addBtn.addEventListener('click', () => addTicker(tickerInput.value));
        tickerInput.addEventListener('keydown', e => { if (e.key === 'Enter') addTicker(tickerInput.value); });
        saveWsBtn.addEventListener('click', saveWorkspace);
        loadWsBtn.addEventListener('click', loadWorkspace);

        // Grid-level drag handlers for reordering in gaps between cards
        grid.addEventListener('dragover', (e) => {
            if (dragSourcePanelId == null) return;
            e.preventDefault();
            const idx = getInsertIndex(e.clientX, e.clientY);
            dropInsertIdx = idx;
            if (idx >= 0) {
                showDropIndicatorAt(idx);
                document.querySelectorAll('.ticker-card.drag-over').forEach(el => el.classList.remove('drag-over'));
            } else {
                hideDropIndicator();
            }
        });
        grid.addEventListener('drop', (e) => {
            if (dragSourcePanelId == null) return;
            // Only handle if the drop wasn't already caught by a card
            if (e.target === grid || e.target.classList?.contains('drop-indicator')) {
                e.preventDefault();
                hideDropIndicator();
                const sourcePanelId = parseInt(e.dataTransfer.getData('text/plain'));
                if (isNaN(sourcePanelId)) return;
                const idx = getInsertIndex(e.clientX, e.clientY);
                if (idx >= 0) movePanel(sourcePanelId, idx);
            }
        });
        grid.addEventListener('dragleave', (e) => {
            if (!grid.contains(e.relatedTarget)) hideDropIndicator();
        });

        // ── Init ──
        async function init() {
            showStatus('Loading forex rates...');
            await fetchAllForex();
            const missing = [];
            if (!state.forexData['EURUSD']) missing.push('EUR/USD');
            if (!state.forexData['USDSEK']) missing.push('USD/SEK');
            if (missing.length) {
                showStatus(`Warning: Could not load forex data for ${missing.join(', ')}. Some conversions may not work.`, true);
            } else {
                showStatus('Loading tickers...');
            }
            await Promise.all(DEFAULT_TICKERS.map(symbol => loadTicker(symbol)));
            showStatus('');
        }

        init();
    })();
    </script>
</body>
</html>
